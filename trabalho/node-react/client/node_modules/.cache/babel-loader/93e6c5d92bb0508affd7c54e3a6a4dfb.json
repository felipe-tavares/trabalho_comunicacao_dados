{"ast":null,"code":"import * as React from 'react';\nimport { getStateFromPath as getStateFromPathDefault, getPathFromState as getPathFromStateDefault, getActionFromState } from '@react-navigation/core';\nimport ServerContext from './ServerContext';\n\nconst getStateLength = state => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\nexport default function useLinking(ref, {\n  enabled = true,\n  config,\n  getStateFromPath = getStateFromPathDefault,\n  getPathFromState = getPathFromStateDefault\n}) {\n  React.useEffect(() => {\n    if (enabled !== false && isUsingLinking) {\n      throw new Error(['Looks like you have configured linking in multiple places. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Make sure that:', \"- You are not using both 'linking' prop and 'useLinking'\", \"- You don't have 'useLinking' in multiple components\"].join('\\n').trim());\n    } else {\n      isUsingLinking = enabled !== false;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  }); // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n\n  const enabledRef = React.useRef(enabled);\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n  React.useEffect(() => {\n    enabledRef.current = enabled;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, enabled, getPathFromState, getStateFromPath]);\n  const server = React.useContext(ServerContext);\n  const getInitialState = React.useCallback(() => {\n    let value;\n\n    if (enabledRef.current) {\n      var _server$location;\n\n      const location = (_server$location = server === null || server === void 0 ? void 0 : server.location) !== null && _server$location !== void 0 ? _server$location : typeof window !== 'undefined' ? window.location : undefined;\n      const path = location ? location.pathname + location.search : undefined;\n\n      if (path) {\n        value = getStateFromPathRef.current(path, configRef.current);\n      }\n    } // Make it a thenable to keep consistent with the native impl\n\n\n    const thenable = {\n      then(onfulfilled) {\n        return Promise.resolve(onfulfilled ? onfulfilled(value) : value);\n      },\n\n      catch() {\n        return thenable;\n      }\n\n    };\n    return thenable; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  const previousStateLengthRef = React.useRef(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n  const pendingIndexChangeRef = React.useRef();\n  const pendingStateUpdateRef = React.useRef(false);\n  const pendingStateMultiUpdateRef = React.useRef(false); // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n\n  const numberOfIndicesAhead = React.useRef(0);\n  React.useEffect(() => {\n    const onPopState = () => {\n      var _history$state$index, _history$state;\n\n      const navigation = ref.current;\n\n      if (!navigation || !enabled) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = (_history$state$index = (_history$state = history.state) === null || _history$state === void 0 ? void 0 : _history$state.index) !== null && _history$state$index !== void 0 ? _history$state$index : 0;\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({\n            index: historyIndex\n          }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks = previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current = historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(location.pathname + location.search, configRef.current);\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n          pendingStateUpdateRef.current = true;\n\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(state);\n          }\n        }\n      }\n    };\n\n    window.addEventListener('popstate', onPopState);\n    return () => window.removeEventListener('popstate', onPopState);\n  }, [enabled, ref]);\n  React.useEffect(() => {\n    var _ref$current;\n\n    if (!enabled) {\n      return;\n    }\n\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(ref.current.getRootState());\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      var _history$state$index2, _history$state2;\n\n      history.replaceState({\n        index: (_history$state$index2 = (_history$state2 = history.state) === null || _history$state2 === void 0 ? void 0 : _history$state2.index) !== null && _history$state$index2 !== void 0 ? _history$state$index2 : 0\n      }, '', getPathFromStateRef.current(ref.current.getRootState(), configRef.current));\n    }\n\n    const unsubscribe = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.addListener('state', () => {\n      var _previousStateLengthR, _history$state$index3, _history$state3;\n\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n      const previousStateLength = (_previousStateLengthR = previousStateLengthRef.current) !== null && _previousStateLengthR !== void 0 ? _previousStateLengthR : 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (pendingStateUpdateRef.current && location.pathname + location.search === path) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = (_history$state$index3 = (_history$state3 = history.state) === null || _history$state3 === void 0 ? void 0 : _history$state3.index) !== null && _history$state$index3 !== void 0 ? _history$state$index3 : 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new entries were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({\n            index\n          }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new entries were added, pushState until we have same length\n        // This won't be accurate if multiple entries were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({\n            index\n          }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = Math.min(previousStateLength - stateLength, // We need to keep at least one item in the history\n        // Otherwise we'll exit the page\n        previousHistoryIndexRef.current - 1);\n\n        if (delta > 0) {\n          // We need to set this to ignore the `popstate` event\n          pendingIndexChangeRef.current = index - delta; // If new entries were removed, go back so that we have same length\n\n          history.go(-delta);\n        } else {\n          // We're not going back in history, but the navigation state changed\n          // The URL probably also changed, so we need to re-sync the URL\n          if (location.pathname + location.search !== path) {\n            history.replaceState({\n              index\n            }, '', path);\n            previousHistoryIndexRef.current = index;\n          }\n        }\n      }\n    });\n    return unsubscribe;\n  });\n  return {\n    getInitialState\n  };\n}","map":{"version":3,"sources":["useLinking.tsx"],"names":["getStateFromPath","getPathFromState","getStateLength","state","length","focusedState","isUsingLinking","enabled","getPathFromStateDefault","React","enabledRef","configRef","getStateFromPathRef","getPathFromStateRef","server","getInitialState","location","window","path","value","thenable","then","Promise","onfulfilled","catch","previousStateLengthRef","previousHistoryIndexRef","pendingIndexChangeRef","pendingStateUpdateRef","pendingStateMultiUpdateRef","numberOfIndicesAhead","onPopState","navigation","ref","previousHistoryIndex","historyIndex","history","canGoBack","numberOfBacks","index","i","action","getActionFromState","unsubscribe","previousStateLength","stateLength","l","delta","Math"],"mappings":"AAAA,OAAO,KAAP,KAAA,MAAA,OAAA;AACA,SACEA,gBAAgB,IADlB,uBAAA,EAEEC,gBAAgB,IAFlB,uBAAA,EAAA,kBAAA,QAAA,wBAAA;AAOA,OAAA,aAAA,MAAA,iBAAA;;AAcA,MAAMC,cAAc,GAAIC,KAAD,IAA4B;AACjD,MAAIC,MAAM,GAAV,CAAA;;AAEA,MAAID,KAAK,CAAT,OAAA,EAAmB;AACjBC,IAAAA,MAAM,GAAGD,KAAK,CAALA,OAAAA,CAATC,MAAAA;AADF,GAAA,MAEO;AACLA,IAAAA,MAAM,GAAGD,KAAK,CAALA,KAAAA,GAATC,CAAAA;AACD;;AAED,QAAMC,YAAY,GAAGF,KAAK,CAALA,MAAAA,CAAaA,KAAK,CAAlBA,KAAAA,EAArB,KAAA;;AAEA,MAAIE,YAAY,IAAI,CAACA,YAAY,CAAjC,KAAA,EAAyC;AACvC;AACAD,IAAAA,MAAM,IAAIF,cAAc,CAAdA,YAAc,CAAdA,GAAVE,CAAAA;AACD;;AAED,SAAA,MAAA;AAhBF,CAAA;;AAmBA,IAAIE,cAAc,GAAlB,KAAA;AAEA,eAAe,SAAA,UAAA,CAAA,GAAA,EAEb;AACEC,EAAAA,OAAO,GADT,IAAA;AAAA,EAAA,MAAA;AAGEP,EAAAA,gBAAgB,GAHlB,uBAAA;AAIEC,EAAAA,gBAAgB,GAAGO;AAJrB,CAFa,EAQb;AACAC,EAAAA,KAAK,CAALA,SAAAA,CAAgB,MAAM;AACpB,QAAIF,OAAO,KAAPA,KAAAA,IAAJ,cAAA,EAAyC;AACvC,YAAM,IAAA,KAAA,CACJ,CAAA,kLAAA,EAAA,0DAAA,EAAA,sDAAA,EAAA,IAAA,CAAA,IAAA,EADF,IACE,EADI,CAAN;AADF,KAAA,MAUO;AACLD,MAAAA,cAAc,GAAGC,OAAO,KAAxBD,KAAAA;AACD;;AAED,WAAO,MAAM;AACXA,MAAAA,cAAc,GAAdA,KAAAA;AADF,KAAA;AAhBF,GACAG,EADA,CAqBA;AACA;AACA;;AACA,QAAMC,UAAU,GAAGD,KAAK,CAALA,MAAAA,CAAnB,OAAmBA,CAAnB;AACA,QAAME,SAAS,GAAGF,KAAK,CAALA,MAAAA,CAAlB,MAAkBA,CAAlB;AACA,QAAMG,mBAAmB,GAAGH,KAAK,CAALA,MAAAA,CAA5B,gBAA4BA,CAA5B;AACA,QAAMI,mBAAmB,GAAGJ,KAAK,CAALA,MAAAA,CAA5B,gBAA4BA,CAA5B;AAEAA,EAAAA,KAAK,CAALA,SAAAA,CAAgB,MAAM;AACpBC,IAAAA,UAAU,CAAVA,OAAAA,GAAAA,OAAAA;AACAC,IAAAA,SAAS,CAATA,OAAAA,GAAAA,MAAAA;AACAC,IAAAA,mBAAmB,CAAnBA,OAAAA,GAAAA,gBAAAA;AACAC,IAAAA,mBAAmB,CAAnBA,OAAAA,GAAAA,gBAAAA;AAJFJ,GAAAA,EAKG,CAAA,MAAA,EAAA,OAAA,EAAA,gBAAA,EALHA,gBAKG,CALHA;AAOA,QAAMK,MAAM,GAAGL,KAAK,CAALA,UAAAA,CAAf,aAAeA,CAAf;AAEA,QAAMM,eAAe,GAAG,KAAK,CAAL,WAAA,CAAkB,MAAM;AAC9C,QAAA,KAAA;;AAEA,QAAIL,UAAU,CAAd,OAAA,EAAwB;AAAA,UAAA,gBAAA;;AACtB,YAAMM,QAAQ,GAAA,CAAA,gBAAA,GACZF,MADY,KAAA,IACZA,IAAAA,MADY,KAAA,KAAA,CACZA,GADY,KAAA,CACZA,GAAAA,MAAM,CADM,QAAA,MAAA,IAAA,IAAA,gBAAA,KAAA,KAAA,CAAA,GAAA,gBAAA,GAEX,OAAA,MAAA,KAAA,WAAA,GAAgCG,MAAM,CAAtC,QAAA,GAFH,SAAA;AAIA,YAAMC,IAAI,GAAGF,QAAQ,GAAGA,QAAQ,CAARA,QAAAA,GAAoBA,QAAQ,CAA/B,MAAA,GAArB,SAAA;;AAEA,UAAA,IAAA,EAAU;AACRG,QAAAA,KAAK,GAAGP,mBAAmB,CAAnBA,OAAAA,CAAAA,IAAAA,EAAkCD,SAAS,CAAnDQ,OAAQP,CAARO;AACD;AAZ2C,KAAA,CAe9C;;;AACA,UAAMC,QAAQ,GAAG;AACfC,MAAAA,IAAI,CAAA,WAAA,EAAyD;AAC3D,eAAOC,OAAO,CAAPA,OAAAA,CAAgBC,WAAW,GAAGA,WAAW,CAAd,KAAc,CAAd,GAAlC,KAAOD,CAAP;AAFa,OAAA;;AAIfE,MAAAA,KAAK,GAAG;AACN,eAAA,QAAA;AACD;;AANc,KAAjB;AASA,WAzB8C,QAyB9C,CAzB8C,CA0B9C;AA1BsB,GAAA,EAAxB,EAAwB,CAAxB;AA6BA,QAAMC,sBAAsB,GAAGhB,KAAK,CAALA,MAAAA,CAA/B,SAA+BA,CAA/B;AACA,QAAMiB,uBAAuB,GAAGjB,KAAK,CAALA,MAAAA,CAAhC,CAAgCA,CAAhC;AAEA,QAAMkB,qBAAqB,GAAGlB,KAAK,CAAnC,MAA8BA,EAA9B;AACA,QAAMmB,qBAAqB,GAAGnB,KAAK,CAALA,MAAAA,CAA9B,KAA8BA,CAA9B;AACA,QAAMoB,0BAA0B,GAAGpB,KAAK,CAALA,MAAAA,CAxEnC,KAwEmCA,CAAnC,CAxEA,CA0EA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMqB,oBAAoB,GAAGrB,KAAK,CAALA,MAAAA,CAA7B,CAA6BA,CAA7B;AAEAA,EAAAA,KAAK,CAALA,SAAAA,CAAgB,MAAM;AACpB,UAAMsB,UAAU,GAAG,MAAM;AAAA,UAAA,oBAAA,EAAA,cAAA;;AACvB,YAAMC,UAAU,GAAGC,GAAG,CAAtB,OAAA;;AAEA,UAAI,CAAA,UAAA,IAAe,CAAnB,OAAA,EAA6B;AAC3B;AACD;;AAED,YAAMC,oBAAoB,GAAGR,uBAAuB,CAApD,OAAA;AACA,YAAMS,YAAY,GAAA,CAAA,oBAAA,GAAA,CAAA,cAAA,GAAGC,OAAO,CAAV,KAAA,MAAA,IAAA,IAAA,cAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAGA,cAAAA,CAAH,KAAA,MAAA,IAAA,IAAA,oBAAA,KAAA,KAAA,CAAA,GAAA,oBAAA,GAAlB,CAAA;AAEAV,MAAAA,uBAAuB,CAAvBA,OAAAA,GAAAA,YAAAA;;AAEA,UAAIC,qBAAqB,CAArBA,OAAAA,KAAJ,YAAA,EAAoD;AAClDA,QAAAA,qBAAqB,CAArBA,OAAAA,GAAAA,SAAAA;AACA;AACD;;AAED,YAAMxB,KAAK,GAAG6B,UAAU,CAAxB,YAAcA,EAAd;AACA,YAAMd,IAAI,GAAGL,mBAAmB,CAAnBA,OAAAA,CAAAA,KAAAA,EAAmCF,SAAS,CAAzD,OAAaE,CAAb;AAEA,UAAIwB,SAAS,GAAb,IAAA;AACA,UAAIC,aAAa,GAAjB,CAAA;;AAEA,UAAIJ,oBAAoB,KAAxB,YAAA,EAA2C;AACzC,YAAIlB,QAAQ,CAARA,QAAAA,GAAoBA,QAAQ,CAA5BA,MAAAA,KAAJ,IAAA,EAAkD;AAChDY,UAAAA,qBAAqB,CAArBA,OAAAA,GAAAA,IAAAA;AACAQ,UAAAA,OAAO,CAAPA,YAAAA,CAAqB;AAAEG,YAAAA,KAAK,EAAEJ;AAAT,WAArBC,EAAAA,EAAAA,EAAAA,IAAAA;AACD;AAJH,OAAA,MAKO,IAAIF,oBAAoB,GAAxB,YAAA,EAAyC;AAC9CI,QAAAA,aAAa,GACXJ,oBAAoB,GAApBA,YAAAA,GAAsCJ,oBAAoB,CAD5DQ,OAAAA;;AAGA,YAAIA,aAAa,GAAjB,CAAA,EAAuB;AACrBT,UAAAA,0BAA0B,CAA1BA,OAAAA,GAAAA,IAAAA;;AAEA,cAAIS,aAAa,GAAjB,CAAA,EAAuB;AACrBT,YAAAA,0BAA0B,CAA1BA,OAAAA,GAAAA,IAAAA;AACD;;AAEDD,UAAAA,qBAAqB,CAArBA,OAAAA,GAAAA,IAAAA;;AAEA,eAAK,IAAIY,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,aAAA,EAAmCA,CAAnC,EAAA,EAAwC;AACtCR,YAAAA,UAAU,CAAVA,MAAAA;AACD;AAXH,SAAA,MAYO;AACLK,UAAAA,SAAS,GAATA,KAAAA;AACD;AACF;;AAED,UAAIH,oBAAoB,GAApBA,YAAAA,IAAuC,CAA3C,SAAA,EAAuD;AACrD,YAAA,SAAA,EAAe;AACbJ,UAAAA,oBAAoB,CAApBA,OAAAA,GACEK,YAAY,GAAZA,oBAAAA,GADFL,CAAAA;AADF,SAAA,MAGO;AACLE,UAAAA,UAAU,CAAVA,MAAAA;AACAF,UAAAA,oBAAoB,CAApBA,OAAAA,IAAgCI,oBAAoB,GAApDJ,YAAAA;AACD;;AAED,cAAM3B,KAAK,GAAGS,mBAAmB,CAAnBA,OAAAA,CACZI,QAAQ,CAARA,QAAAA,GAAoBA,QAAQ,CADhBJ,MAAAA,EAEZD,SAAS,CAFX,OAAcC,CAAd;AAKAiB,QAAAA,0BAA0B,CAA1BA,OAAAA,GAAAA,IAAAA;;AAEA,YAAA,KAAA,EAAW;AACT,gBAAMY,MAAM,GAAGC,kBAAkB,CAAjC,KAAiC,CAAjC;AAEAd,UAAAA,qBAAqB,CAArBA,OAAAA,GAAAA,IAAAA;;AAEA,cAAIa,MAAM,KAAV,SAAA,EAA0B;AACxBT,YAAAA,UAAU,CAAVA,QAAAA,CAAAA,MAAAA;AADF,WAAA,MAEO;AACLA,YAAAA,UAAU,CAAVA,SAAAA,CAAAA,KAAAA;AACD;AACF;AACF;AA5EH,KAAA;;AA+EAf,IAAAA,MAAM,CAANA,gBAAAA,CAAAA,UAAAA,EAAAA,UAAAA;AAEA,WAAO,MAAMA,MAAM,CAANA,mBAAAA,CAAAA,UAAAA,EAAb,UAAaA,CAAb;AAlFFR,GAAAA,EAmFG,CAAA,OAAA,EAnFHA,GAmFG,CAnFHA;AAqFAA,EAAAA,KAAK,CAALA,SAAAA,CAAgB,MAAM;AAAA,QAAA,YAAA;;AACpB,QAAI,CAAJ,OAAA,EAAc;AACZ;AACD;;AAED,QAAIwB,GAAG,CAAHA,OAAAA,IAAeR,sBAAsB,CAAtBA,OAAAA,KAAnB,SAAA,EAAiE;AAC/DA,MAAAA,sBAAsB,CAAtBA,OAAAA,GAAiCvB,cAAc,CAC7C+B,GAAG,CAAHA,OAAAA,CADFR,YACEQ,EAD6C,CAA/CR;AAGD;;AAED,QAAIQ,GAAG,CAAHA,OAAAA,IAAejB,QAAQ,CAARA,QAAAA,GAAoBA,QAAQ,CAA5BA,MAAAA,KAAnB,GAAA,EAAgE;AAAA,UAAA,qBAAA,EAAA,eAAA;;AAC9DoB,MAAAA,OAAO,CAAPA,YAAAA,CACE;AAAEG,QAAAA,KAAK,EAAA,CAAA,qBAAA,GAAA,CAAA,eAAA,GAAEH,OAAO,CAAT,KAAA,MAAA,IAAA,IAAA,eAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAEA,eAAAA,CAAF,KAAA,MAAA,IAAA,IAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,qBAAA,GAA0B;AAAjC,OADFA,EAAAA,EAAAA,EAGEvB,mBAAmB,CAAnBA,OAAAA,CACEoB,GAAG,CAAHA,OAAAA,CADFpB,YACEoB,EADFpB,EAEEF,SAAS,CALbyB,OAGEvB,CAHFuB;AAQD;;AAED,UAAMO,WAAW,GAAA,CAAA,YAAA,GAAG,GAAG,CAAN,OAAA,MAAA,IAAA,IAAA,YAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAG,YAAA,CAAA,WAAA,CAAA,OAAA,EAAkC,MAAM;AAAA,UAAA,qBAAA,EAAA,qBAAA,EAAA,eAAA;;AAC1D,YAAMX,UAAU,GAAGC,GAAG,CAAtB,OAAA;;AAEA,UAAI,CAAJ,UAAA,EAAiB;AACf;AACD;;AAED,YAAM9B,KAAK,GAAG6B,UAAU,CAAxB,YAAcA,EAAd;AACA,YAAMd,IAAI,GAAGL,mBAAmB,CAAnBA,OAAAA,CAAAA,KAAAA,EAAmCF,SAAS,CAAzD,OAAaE,CAAb;AAEA,YAAM+B,mBAAmB,GAAA,CAAA,qBAAA,GAAGnB,sBAAsB,CAAzB,OAAA,MAAA,IAAA,IAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,qBAAA,GAAzB,CAAA;AACA,YAAMoB,WAAW,GAAG3C,cAAc,CAAlC,KAAkC,CAAlC;;AAEA,UAAI2B,0BAA0B,CAA9B,OAAA,EAAwC;AACtC,YAAIb,QAAQ,CAARA,QAAAA,GAAoBA,QAAQ,CAA5BA,MAAAA,KAAJ,IAAA,EAAkD;AAChDa,UAAAA,0BAA0B,CAA1BA,OAAAA,GAAAA,KAAAA;AADF,SAAA,MAEO;AACL;AACD;AACF;;AAEDJ,MAAAA,sBAAsB,CAAtBA,OAAAA,GAAAA,WAAAA;;AAEA,UACEG,qBAAqB,CAArBA,OAAAA,IACAZ,QAAQ,CAARA,QAAAA,GAAoBA,QAAQ,CAA5BA,MAAAA,KAFF,IAAA,EAGE;AACAY,QAAAA,qBAAqB,CAArBA,OAAAA,GAAAA,KAAAA;AACA;AACD;;AAED,UAAIW,KAAK,GAAA,CAAA,qBAAA,GAAA,CAAA,eAAA,GAAGH,OAAO,CAAV,KAAA,MAAA,IAAA,IAAA,eAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAGA,eAAAA,CAAH,KAAA,MAAA,IAAA,IAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,qBAAA,GAAT,CAAA;;AAEA,UAAIQ,mBAAmB,KAAvB,WAAA,EAAyC;AACvC;AACA,YAAI5B,QAAQ,CAARA,QAAAA,GAAoBA,QAAQ,CAA5BA,MAAAA,KAAJ,IAAA,EAAkD;AAChDoB,UAAAA,OAAO,CAAPA,YAAAA,CAAqB;AAAEG,YAAAA;AAAF,WAArBH,EAAAA,EAAAA,EAAAA,IAAAA;AACAV,UAAAA,uBAAuB,CAAvBA,OAAAA,GAAAA,KAAAA;AACD;AALH,OAAA,MAMO,IAAImB,WAAW,GAAf,mBAAA,EAAuC;AAC5C;AACA;AACA,aAAK,IAAIL,CAAC,GAAL,CAAA,EAAWM,CAAC,GAAGD,WAAW,GAA/B,mBAAA,EAAuDL,CAAC,GAAxD,CAAA,EAA8DA,CAA9D,EAAA,EAAmE;AACjED,UAAAA,KAAK;AACLH,UAAAA,OAAO,CAAPA,SAAAA,CAAkB;AAAEG,YAAAA;AAAF,WAAlBH,EAAAA,EAAAA,EAAAA,IAAAA;AACD;;AAEDV,QAAAA,uBAAuB,CAAvBA,OAAAA,GAAAA,KAAAA;AARK,OAAA,MASA,IAAIkB,mBAAmB,GAAvB,WAAA,EAAuC;AAC5C,cAAMG,KAAK,GAAGC,IAAI,CAAJA,GAAAA,CACZJ,mBAAmB,GADPI,WAAAA,EAEZ;AACA;AACAtB,QAAAA,uBAAuB,CAAvBA,OAAAA,GAJF,CAAcsB,CAAd;;AAOA,YAAID,KAAK,GAAT,CAAA,EAAe;AACb;AACApB,UAAAA,qBAAqB,CAArBA,OAAAA,GAAgCY,KAAK,GAFxB,KAEbZ,CAFa,CAIb;;AACAS,UAAAA,OAAO,CAAPA,EAAAA,CAAW,CAAXA,KAAAA;AALF,SAAA,MAMO;AACL;AACA;AACA,cAAIpB,QAAQ,CAARA,QAAAA,GAAoBA,QAAQ,CAA5BA,MAAAA,KAAJ,IAAA,EAAkD;AAChDoB,YAAAA,OAAO,CAAPA,YAAAA,CAAqB;AAAEG,cAAAA;AAAF,aAArBH,EAAAA,EAAAA,EAAAA,IAAAA;AACAV,YAAAA,uBAAuB,CAAvBA,OAAAA,GAAAA,KAAAA;AACD;AACF;AACF;AAtEH,KAAoB,CAApB;AAyEA,WAAA,WAAA;AA/FFjB,GAAAA;AAkGA,SAAO;AACLM,IAAAA;AADK,GAAP;AAGD","sourcesContent":["import * as React from 'react';\nimport {\n  getStateFromPath as getStateFromPathDefault,\n  getPathFromState as getPathFromStateDefault,\n  NavigationContainerRef,\n  NavigationState,\n  getActionFromState,\n} from '@react-navigation/core';\nimport ServerContext from './ServerContext';\nimport { LinkingOptions } from './types';\n\ntype ResultState = ReturnType<typeof getStateFromPathDefault>;\n\ntype HistoryState = { index: number };\n\ndeclare const history: {\n  state?: HistoryState;\n  go(delta: number): void;\n  pushState(state: HistoryState, title: string, url: string): void;\n  replaceState(state: HistoryState, title: string, url: string): void;\n};\n\nconst getStateLength = (state: NavigationState) => {\n  let length = 0;\n\n  if (state.history) {\n    length = state.history.length;\n  } else {\n    length = state.index + 1;\n  }\n\n  const focusedState = state.routes[state.index].state;\n\n  if (focusedState && !focusedState.stale) {\n    // If the focused route has history entries, we need to count them as well\n    length += getStateLength(focusedState as NavigationState) - 1;\n  }\n\n  return length;\n};\n\nlet isUsingLinking = false;\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef>,\n  {\n    enabled = true,\n    config,\n    getStateFromPath = getStateFromPathDefault,\n    getPathFromState = getPathFromStateDefault,\n  }: LinkingOptions\n) {\n  React.useEffect(() => {\n    if (enabled !== false && isUsingLinking) {\n      throw new Error(\n        [\n          'Looks like you have configured linking in multiple places. This is likely an error since URL integration should only be handled in one place to avoid conflicts. Make sure that:',\n          \"- You are not using both 'linking' prop and 'useLinking'\",\n          \"- You don't have 'useLinking' in multiple components\",\n        ]\n          .join('\\n')\n          .trim()\n      );\n    } else {\n      isUsingLinking = enabled !== false;\n    }\n\n    return () => {\n      isUsingLinking = false;\n    };\n  });\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const enabledRef = React.useRef(enabled);\n  const configRef = React.useRef(config);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getPathFromStateRef = React.useRef(getPathFromState);\n\n  React.useEffect(() => {\n    enabledRef.current = enabled;\n    configRef.current = config;\n    getStateFromPathRef.current = getStateFromPath;\n    getPathFromStateRef.current = getPathFromState;\n  }, [config, enabled, getPathFromState, getStateFromPath]);\n\n  const server = React.useContext(ServerContext);\n\n  const getInitialState = React.useCallback(() => {\n    let value: ResultState | undefined;\n\n    if (enabledRef.current) {\n      const location =\n        server?.location ??\n        (typeof window !== 'undefined' ? window.location : undefined);\n\n      const path = location ? location.pathname + location.search : undefined;\n\n      if (path) {\n        value = getStateFromPathRef.current(path, configRef.current);\n      }\n    }\n\n    // Make it a thenable to keep consistent with the native impl\n    const thenable = {\n      then(onfulfilled?: (state: ResultState | undefined) => void) {\n        return Promise.resolve(onfulfilled ? onfulfilled(value) : value);\n      },\n      catch() {\n        return thenable;\n      },\n    };\n\n    return thenable as PromiseLike<ResultState | undefined>;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const previousStateLengthRef = React.useRef<number | undefined>(undefined);\n  const previousHistoryIndexRef = React.useRef(0);\n\n  const pendingIndexChangeRef = React.useRef<number | undefined>();\n  const pendingStateUpdateRef = React.useRef<boolean>(false);\n  const pendingStateMultiUpdateRef = React.useRef<boolean>(false);\n\n  // If we're navigating ahead >1, we're not restoring whole state,\n  // but just navigate to the selected route not caring about previous routes\n  // therefore if we need to go back, we need to pop screen and navigate to the new one\n  // Possibly, we will need to reuse the same mechanism.\n  // E.g. if we went ahead+4 (numberOfIndicesAhead = 3), and back-2,\n  // actually we need to pop the screen we navigated\n  // and navigate again, setting numberOfIndicesAhead to 1.\n  const numberOfIndicesAhead = React.useRef(0);\n\n  React.useEffect(() => {\n    const onPopState = () => {\n      const navigation = ref.current;\n\n      if (!navigation || !enabled) {\n        return;\n      }\n\n      const previousHistoryIndex = previousHistoryIndexRef.current;\n      const historyIndex = history.state?.index ?? 0;\n\n      previousHistoryIndexRef.current = historyIndex;\n\n      if (pendingIndexChangeRef.current === historyIndex) {\n        pendingIndexChangeRef.current = undefined;\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      let canGoBack = true;\n      let numberOfBacks = 0;\n\n      if (previousHistoryIndex === historyIndex) {\n        if (location.pathname + location.search !== path) {\n          pendingStateUpdateRef.current = true;\n          history.replaceState({ index: historyIndex }, '', path);\n        }\n      } else if (previousHistoryIndex > historyIndex) {\n        numberOfBacks =\n          previousHistoryIndex - historyIndex - numberOfIndicesAhead.current;\n\n        if (numberOfBacks > 0) {\n          pendingStateMultiUpdateRef.current = true;\n\n          if (numberOfBacks > 1) {\n            pendingStateMultiUpdateRef.current = true;\n          }\n\n          pendingStateUpdateRef.current = true;\n\n          for (let i = 0; i < numberOfBacks; i++) {\n            navigation.goBack();\n          }\n        } else {\n          canGoBack = false;\n        }\n      }\n\n      if (previousHistoryIndex < historyIndex || !canGoBack) {\n        if (canGoBack) {\n          numberOfIndicesAhead.current =\n            historyIndex - previousHistoryIndex - 1;\n        } else {\n          navigation.goBack();\n          numberOfIndicesAhead.current -= previousHistoryIndex - historyIndex;\n        }\n\n        const state = getStateFromPathRef.current(\n          location.pathname + location.search,\n          configRef.current\n        );\n\n        pendingStateMultiUpdateRef.current = true;\n\n        if (state) {\n          const action = getActionFromState(state);\n\n          pendingStateUpdateRef.current = true;\n\n          if (action !== undefined) {\n            navigation.dispatch(action);\n          } else {\n            navigation.resetRoot(state);\n          }\n        }\n      }\n    };\n\n    window.addEventListener('popstate', onPopState);\n\n    return () => window.removeEventListener('popstate', onPopState);\n  }, [enabled, ref]);\n\n  React.useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    if (ref.current && previousStateLengthRef.current === undefined) {\n      previousStateLengthRef.current = getStateLength(\n        ref.current.getRootState()\n      );\n    }\n\n    if (ref.current && location.pathname + location.search === '/') {\n      history.replaceState(\n        { index: history.state?.index ?? 0 },\n        '',\n        getPathFromStateRef.current(\n          ref.current.getRootState(),\n          configRef.current\n        )\n      );\n    }\n\n    const unsubscribe = ref.current?.addListener('state', () => {\n      const navigation = ref.current;\n\n      if (!navigation) {\n        return;\n      }\n\n      const state = navigation.getRootState();\n      const path = getPathFromStateRef.current(state, configRef.current);\n\n      const previousStateLength = previousStateLengthRef.current ?? 1;\n      const stateLength = getStateLength(state);\n\n      if (pendingStateMultiUpdateRef.current) {\n        if (location.pathname + location.search === path) {\n          pendingStateMultiUpdateRef.current = false;\n        } else {\n          return;\n        }\n      }\n\n      previousStateLengthRef.current = stateLength;\n\n      if (\n        pendingStateUpdateRef.current &&\n        location.pathname + location.search === path\n      ) {\n        pendingStateUpdateRef.current = false;\n        return;\n      }\n\n      let index = history.state?.index ?? 0;\n\n      if (previousStateLength === stateLength) {\n        // If no new entries were added to history in our navigation state, we want to replaceState\n        if (location.pathname + location.search !== path) {\n          history.replaceState({ index }, '', path);\n          previousHistoryIndexRef.current = index;\n        }\n      } else if (stateLength > previousStateLength) {\n        // If new entries were added, pushState until we have same length\n        // This won't be accurate if multiple entries were added at once, but that's the best we can do\n        for (let i = 0, l = stateLength - previousStateLength; i < l; i++) {\n          index++;\n          history.pushState({ index }, '', path);\n        }\n\n        previousHistoryIndexRef.current = index;\n      } else if (previousStateLength > stateLength) {\n        const delta = Math.min(\n          previousStateLength - stateLength,\n          // We need to keep at least one item in the history\n          // Otherwise we'll exit the page\n          previousHistoryIndexRef.current - 1\n        );\n\n        if (delta > 0) {\n          // We need to set this to ignore the `popstate` event\n          pendingIndexChangeRef.current = index - delta;\n\n          // If new entries were removed, go back so that we have same length\n          history.go(-delta);\n        } else {\n          // We're not going back in history, but the navigation state changed\n          // The URL probably also changed, so we need to re-sync the URL\n          if (location.pathname + location.search !== path) {\n            history.replaceState({ index }, '', path);\n            previousHistoryIndexRef.current = index;\n          }\n        }\n      }\n    });\n\n    return unsubscribe;\n  });\n\n  return {\n    getInitialState,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}